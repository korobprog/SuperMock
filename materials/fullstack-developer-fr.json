{
  "profession": "fullstack-developer",
  "language": "fr",
  "categories": [
    {
      "id": "interview-questions",
      "name": "Questions d'Entretien",
      "count": 156,
      "icon": "üí¨",
      "color": "bg-blue-100 text-blue-800"
    },
    {
      "id": "technical-tasks",
      "name": "T√¢ches Techniques",
      "count": 89,
      "icon": "‚ö°",
      "color": "bg-green-100 text-green-800"
    },
    {
      "id": "system-design",
      "name": "Conception de Syst√®mes",
      "count": 34,
      "icon": "üèóÔ∏è",
      "color": "bg-purple-100 text-purple-800"
    },
    {
      "id": "behavioral",
      "name": "Questions Comportementales",
      "count": 67,
      "icon": "üß†",
      "color": "bg-orange-100 text-orange-800"
    },
    {
      "id": "algorithms",
      "name": "Algorithmes et Structures de Donn√©es",
      "count": 123,
      "icon": "üìä",
      "color": "bg-red-100 text-red-800"
    },
    {
      "id": "best-practices",
      "name": "Meilleures Pratiques",
      "count": 78,
      "icon": "‚≠ê",
      "color": "bg-yellow-100 text-yellow-800"
    }
  ],
  "materials": [
    {
      "id": 1,
      "title": "D√©veloppement Fullstack : Du Concept au D√©ploiement",
      "description": "Guide complet du d√©veloppement fullstack incluant les pratiques frontend, backend et DevOps",
      "category": "interview-questions",
      "difficulty": "intermediate",
      "readTime": 25,
      "rating": 4.9,
      "reads": 1345,
      "tags": ["Fullstack", "Frontend", "Backend", "DevOps", "Architecture"],
      "content": "# D√©veloppement Fullstack : Du Concept au D√©ploiement\n\n## Introduction\n\nUn d√©veloppeur fullstack est un sp√©cialiste qui peut travailler √† la fois avec les parties frontend et backend d'une application, ainsi que comprendre les processus de d√©ploiement et DevOps.\n\n## Architecture d'Application Fullstack\n\n```javascript\n// Structure du projet\nproject/\n‚îú‚îÄ‚îÄ frontend/          # Application React/Vue/Angular\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ public/\n‚îÇ   ‚îî‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ backend/           # Serveur Node.js/Python/Java\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ routes/\n‚îÇ   ‚îî‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ database/          # Sch√©mas et migrations\n‚îú‚îÄ‚îÄ docker/           # Configuration Docker\n‚îî‚îÄ‚îÄ docs/             # Documentation\n```\n\n## Frontend (React + TypeScript)\n\n```typescript\n// Composant avec TypeScript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface UserListProps {\n  users: User[];\n  onUserSelect: (user: User) => void;\n}\n\nconst UserList: React.FC<UserListProps> = ({ users, onUserSelect }) => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleUserClick = async (user: User) => {\n    try {\n      setLoading(true);\n      await onUserSelect(user);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"user-list\">\n      {users.map(user => (\n        <div key={user.id} onClick={() => handleUserClick(user)}>\n          <h3>{user.name}</h3>\n          <p>{user.email}</p>\n        </div>\n      ))}\n    </div>\n  );\n};\n```\n\n## Backend (Node.js + Express)\n\n```javascript\n// Serveur API avec Express\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\n// Middleware\napp.use(helmet());\napp.use(cors({\n  origin: process.env.FRONTEND_URL,\n  credentials: true\n}));\n\n// Limitation de d√©bit\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // maximum 100 requ√™tes\n});\napp.use('/api/', limiter);\n\n// Routes\napp.use('/api/users', require('./routes/users'));\napp.use('/api/auth', require('./routes/auth'));\napp.use('/api/products', require('./routes/products'));\n\n// Gestion d'erreurs\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Erreur interne du serveur' });\n});\n\nmodule.exports = app;\n```\n\n## Base de Donn√©es (PostgreSQL + Prisma)\n\n```javascript\n// Sch√©ma Prisma\n// prisma/schema.prisma\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  password  String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  posts     Post[]\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String\n  published Boolean  @default(false)\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n```\n\n## Int√©gration API\n\n```typescript\n// Client API\nclass ApiClient {\n  private baseURL: string;\n  private token: string | null = null;\n\n  constructor(baseURL: string) {\n    this.baseURL = baseURL;\n  }\n\n  setToken(token: string) {\n    this.token = token;\n  }\n\n  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${this.baseURL}${endpoint}`;\n    const config: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(this.token && { Authorization: `Bearer ${this.token}` }),\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    const response = await fetch(url, config);\n\n    if (!response.ok) {\n      throw new Error(`Erreur HTTP ! statut: ${response.status}`);\n    }\n\n    return response.json();\n  }\n\n  // API Utilisateurs\n  async getUsers(): Promise<User[]> {\n    return this.request<User[]>('/api/users');\n  }\n\n  async createUser(userData: Omit<User, 'id'>): Promise<User> {\n    return this.request<User>('/api/users', {\n      method: 'POST',\n      body: JSON.stringify(userData),\n    });\n  }\n\n  // API Authentification\n  async login(credentials: { email: string; password: string }): Promise<{ token: string }> {\n    const result = await this.request<{ token: string }>('/api/auth/login', {\n      method: 'POST',\n      body: JSON.stringify(credentials),\n    });\n    this.setToken(result.token);\n    return result;\n  }\n}\n\n// Utilisation\nconst api = new ApiClient('http://localhost:3000');\n```\n\n## Gestion d'√âtat (Redux Toolkit)\n\n```typescript\n// Store Redux\nimport { configureStore } from '@reduxjs/toolkit';\nimport authReducer from './slices/authSlice';\nimport usersReducer from './slices/usersSlice';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    users: usersReducer,\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: ['persist/PERSIST'],\n      },\n    }),\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Slice d'authentification\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { api } from '../services/api';\n\ninterface AuthState {\n  user: User | null;\n  token: string | null;\n  loading: boolean;\n  error: string | null;\n}\n\nconst initialState: AuthState = {\n  user: null,\n  token: localStorage.getItem('token'),\n  loading: false,\n  error: null,\n};\n\nexport const login = createAsyncThunk(\n  'auth/login',\n  async (credentials: { email: string; password: string }) => {\n    const response = await api.login(credentials);\n    return response;\n  }\n);\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    logout: (state) => {\n      state.user = null;\n      state.token = null;\n      localStorage.removeItem('token');\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(login.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(login.fulfilled, (state, action) => {\n        state.loading = false;\n        state.token = action.payload.token;\n        localStorage.setItem('token', action.payload.token);\n      })\n      .addCase(login.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message || 'Erreur de connexion';\n      });\n  },\n});\n\nexport const { logout } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n## Docker et D√©ploiement\n\n```dockerfile\n# Dockerfile pour frontend\nFROM node:18-alpine as build\n\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\nRUN npm run build\n\nFROM nginx:alpine\nCOPY --from=build /app/build /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/nginx.conf\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:80\"\n    depends_on:\n      - backend\n    environment:\n      - REACT_APP_API_URL=http://localhost:3001\n\n  backend:\n    build: ./backend\n    ports:\n      - \"3001:3001\"\n    depends_on:\n      - postgres\n      - redis\n    environment:\n      - DATABASE_URL=postgresql://user:password@postgres:5432/myapp\n      - REDIS_URL=redis://redis:6379\n      - JWT_SECRET=your-secret-key\n\n  postgres:\n    image: postgres:15\n    environment:\n      - POSTGRES_DB=myapp\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n\nvolumes:\n  postgres_data:\n```\n\n## Pipeline CI/CD\n\n```yaml\n# .github/workflows/deploy.yml\nname: D√©ployer en Production\n\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Configurer Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Installer les d√©pendances\n        run: |\n          cd frontend && npm ci\n          cd ../backend && npm ci\n      \n      - name: Ex√©cuter les tests\n        run: |\n          cd frontend && npm test\n          cd ../backend && npm test\n      \n      - name: Construire\n        run: |\n          cd frontend && npm run build\n          cd ../backend && npm run build\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - name: D√©ployer sur le serveur\n        run: |\n          # Commandes SSH pour le d√©ploiement\n          ssh user@server 'cd /app && git pull && docker-compose up -d'\n```\n\n## Surveillance et Journalisation\n\n```javascript\n// Logger Winston\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  defaultMeta: { service: 'fullstack-app' },\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' }),\n  ],\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  logger.add(new winston.transports.Console({\n    format: winston.format.simple()\n  }));\n}\n\n// Utilisation\nlogger.info('Application d√©marr√©e', { port: process.env.PORT });\nlogger.error('Erreur de base de donn√©es', { error: err.message });\n```\n\n## Tests\n\n```typescript\n// Jest + React Testing Library\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport { store } from '../store';\nimport UserList from './UserList';\n\nconst mockUsers = [\n  { id: 1, name: 'Jean', email: 'jean@example.com' },\n  { id: 2, name: 'Marie', email: 'marie@example.com' }\n];\n\nconst mockOnUserSelect = jest.fn();\n\ndescribe('UserList', () => {\n  it('affiche la liste des utilisateurs', () => {\n    render(\n      <Provider store={store}>\n        <UserList users={mockUsers} onUserSelect={mockOnUserSelect} />\n      </Provider>\n    );\n\n    expect(screen.getByText('Jean')).toBeInTheDocument();\n    expect(screen.getByText('Marie')).toBeInTheDocument();\n  });\n\n  it('appelle onUserSelect lors du clic sur un utilisateur', async () => {\n    render(\n      <Provider store={store}>\n        <UserList users={mockUsers} onUserSelect={mockOnUserSelect} />\n      </Provider>\n    );\n\n    fireEvent.click(screen.getByText('Jean'));\n\n    await waitFor(() => {\n      expect(mockOnUserSelect).toHaveBeenCalledWith(mockUsers[0]);\n    });\n  });\n});\n```\n\n## Meilleures Pratiques\n\n1. **S√©paration des Responsabilit√©s**: S√©parer clairement la logique frontend et backend\n2. **S√©curit√© des Types**: Utiliser TypeScript pour une meilleure exp√©rience de d√©veloppement\n3. **S√©curit√©**: Valider les donn√©es √† tous les niveaux\n4. **Performance**: Optimiser les requ√™tes et la mise en cache\n5. **√âvolutivit√©**: Concevoir en pensant √† la croissance\n6. **Surveillance**: Suivre les performances et les erreurs\n7. **Documentation**: Maintenir une documentation √† jour\n8. **Tests**: Couvrir le code avec des tests\n\n## Conclusion\n\nLe d√©veloppement fullstack n√©cessite une compr√©hension approfondie de toutes les couches de l'application. Un d√©veloppeur fullstack performant doit pouvoir travailler efficacement avec le frontend, le backend et l'infrastructure.",
      "isNew": false,
      "isPopular": true,
      "createdAt": "2024-01-01T00:00:00Z"
    }
  ]
}
