{
  "profession": "backend-developer",
  "language": "en",
  "categories": [
    {
      "id": "interview-questions",
      "name": "Interview Questions",
      "count": 156,
      "icon": "💬",
      "color": "bg-blue-100 text-blue-800"
    },
    {
      "id": "technical-tasks",
      "name": "Technical Tasks",
      "count": 89,
      "icon": "⚡",
      "color": "bg-green-100 text-green-800"
    },
    {
      "id": "system-design",
      "name": "System Design",
      "count": 34,
      "icon": "🏗️",
      "color": "bg-purple-100 text-purple-800"
    },
    {
      "id": "behavioral",
      "name": "Behavioral Questions",
      "count": 67,
      "icon": "🧠",
      "color": "bg-orange-100 text-orange-800"
    },
    {
      "id": "algorithms",
      "name": "Algorithms & Data Structures",
      "count": 123,
      "icon": "📊",
      "color": "bg-red-100 text-red-800"
    },
    {
      "id": "best-practices",
      "name": "Best Practices",
      "count": 78,
      "icon": "⭐",
      "color": "bg-yellow-100 text-yellow-800"
    }
  ],
  "materials": [
    {
      "id": 1,
      "title": "Node.js: Fundamentals and Architecture",
      "description": "Deep dive into Node.js architecture, event loop, and core principles for backend development",
      "category": "interview-questions",
      "difficulty": "intermediate",
      "readTime": 20,
      "rating": 4.8,
      "reads": 1156,
      "tags": ["Node.js", "JavaScript", "Backend", "Architecture"],
      "content": "# Node.js: Fundamentals and Architecture\n\n## Introduction\n\nNode.js is a JavaScript runtime environment built on Chrome's V8 engine that enables server-side JavaScript execution.\n\n## Node.js Architecture\n\n```javascript\n// Event Loop Example\nconsole.log('1');\nsetTimeout(() => console.log('2'), 0);\nsetImmediate(() => console.log('3'));\nprocess.nextTick(() => console.log('4'));\nconsole.log('5');\n\n// Output: 1, 5, 4, 2, 3\n```\n\n## Module System\n\n```javascript\n// CommonJS\nconst fs = require('fs');\nconst path = require('path');\n\n// ES Modules\nimport fs from 'fs';\nimport path from 'path';\n\n// Creating a module\nmodule.exports = {\n  add: (a, b) => a + b,\n  subtract: (a, b) => a - b\n};\n```\n\n## Asynchronous Programming\n\n```javascript\n// Callbacks\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error:', err);\n    return;\n  }\n  console.log('Data:', data);\n});\n\n// Promises\nconst readFilePromise = (filename) => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filename, 'utf8', (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n};\n\n// Async/Await\nasync function readFiles() {\n  try {\n    const data1 = await readFilePromise('file1.txt');\n    const data2 = await readFilePromise('file2.txt');\n    console.log(data1, data2);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n```\n\n## HTTP Server\n\n```javascript\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'application/json' });\n  \n  const response = {\n    message: 'Hello, World!',\n    timestamp: new Date().toISOString()\n  };\n  \n  res.end(JSON.stringify(response));\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n```\n\n## Express.js Framework\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Routes\napp.get('/api/users', (req, res) => {\n  res.json({ users: [] });\n});\n\napp.post('/api/users', (req, res) => {\n  const { name, email } = req.body;\n  // User creation logic\n  res.status(201).json({ message: 'User created' });\n});\n\napp.listen(3000, () => {\n  console.log('Express server running');\n});\n```\n\n## Error Handling\n\n```javascript\n// Global error handlers\nprocess.on('uncaughtException', (err) => {\n  console.error('Uncaught Exception:', err);\n  process.exit(1);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection:', reason);\n});\n\n// Express error handling middleware\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Something went wrong!' });\n});\n```\n\n## Best Practices\n\n### Security\n```javascript\n// Use helmet for security headers\nconst helmet = require('helmet');\napp.use(helmet());\n\n// Input validation\nconst { body, validationResult } = require('express-validator');\n\napp.post('/api/users', [\n  body('email').isEmail(),\n  body('password').isLength({ min: 6 })\n], (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  // Process valid data\n});\n```\n\n### Performance\n```javascript\n// Use streams for large files\nconst fs = require('fs');\nconst readStream = fs.createReadStream('large-file.txt');\nconst writeStream = fs.createWriteStream('output.txt');\n\nreadStream.pipe(writeStream);\n\n// Caching with Redis\nconst redis = require('redis');\nconst client = redis.createClient();\n\nasync function getCachedData(key) {\n  const cached = await client.get(key);\n  if (cached) return JSON.parse(cached);\n  \n  const data = await fetchDataFromDatabase();\n  await client.setex(key, 3600, JSON.stringify(data));\n  return data;\n}\n```\n\n### Testing\n```javascript\n// Unit testing with Jest\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('User API', () => {\n  test('GET /api/users should return users', async () => {\n    const response = await request(app)\n      .get('/api/users')\n      .expect(200);\n    \n    expect(response.body).toHaveProperty('users');\n    expect(Array.isArray(response.body.users)).toBe(true);\n  });\n});\n```\n\n## Conclusion\n\nNode.js provides a powerful platform for building scalable server-side applications. Understanding its architecture and principles is crucial for backend developers.",
      "isNew": false,
      "isPopular": true,
      "createdAt": "2024-01-01T00:00:00Z"
    },
    {
      "id": 2,
      "title": "Database Design and Optimization",
      "description": "Essential database concepts, design patterns, and optimization techniques for backend developers",
      "category": "technical-tasks",
      "difficulty": "intermediate",
      "readTime": 25,
      "rating": 4.7,
      "reads": 892,
      "tags": ["Database", "SQL", "NoSQL", "Performance", "Design"],
      "content": "# Database Design and Optimization\n\n## Database Types\n\n### Relational Databases (SQL)\n```sql\n-- Normalization Example\nCREATE TABLE users (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  username VARCHAR(50) UNIQUE NOT NULL,\n  email VARCHAR(100) UNIQUE NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE posts (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT,\n  title VARCHAR(200) NOT NULL,\n  content TEXT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  FOREIGN KEY (user_id) REFERENCES users(id)\n);\n```\n\n### NoSQL Databases\n```javascript\n// MongoDB Example\nconst mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  username: { type: String, required: true, unique: true },\n  email: { type: String, required: true, unique: true },\n  posts: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Post' }]\n});\n\nconst User = mongoose.model('User', userSchema);\n```\n\n## Indexing Strategies\n\n```sql\n-- Primary Key (automatically indexed)\nCREATE TABLE products (\n  id INT PRIMARY KEY,\n  name VARCHAR(100),\n  category VARCHAR(50)\n);\n\n-- Composite Index\nCREATE INDEX idx_category_name ON products(category, name);\n\n-- Partial Index\nCREATE INDEX idx_active_users ON users(email) WHERE is_active = true;\n```\n\n## Query Optimization\n\n```sql\n-- Use EXPLAIN to analyze queries\nEXPLAIN SELECT u.username, p.title \nFROM users u \nJOIN posts p ON u.id = p.user_id \nWHERE u.created_at > '2024-01-01';\n\n-- Avoid SELECT *\nSELECT id, username, email FROM users WHERE is_active = true;\n\n-- Use LIMIT for pagination\nSELECT * FROM posts ORDER BY created_at DESC LIMIT 10 OFFSET 20;\n```\n\n## Connection Pooling\n\n```javascript\n// PostgreSQL with connection pooling\nconst { Pool } = require('pg');\n\nconst pool = new Pool({\n  user: 'username',\n  host: 'localhost',\n  database: 'mydb',\n  password: 'password',\n  port: 5432,\n  max: 20, // Maximum number of clients\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n});\n\nasync function getUsers() {\n  const client = await pool.connect();\n  try {\n    const result = await client.query('SELECT * FROM users');\n    return result.rows;\n  } finally {\n    client.release();\n  }\n}\n```\n\n## Transaction Management\n\n```javascript\n// ACID Transactions\nasync function transferMoney(fromAccount, toAccount, amount) {\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n    \n    // Deduct from source account\n    await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n      [amount, fromAccount]\n    );\n    \n    // Add to destination account\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toAccount]\n    );\n    \n    await client.query('COMMIT');\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}\n```\n\n## Caching Strategies\n\n```javascript\n// Redis Caching\nconst redis = require('redis');\nconst client = redis.createClient();\n\nasync function getUserWithCache(userId) {\n  // Try cache first\n  const cached = await client.get(`user:${userId}`);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n  \n  // Fetch from database\n  const user = await db.query('SELECT * FROM users WHERE id = $1', [userId]);\n  \n  // Cache for 1 hour\n  await client.setex(`user:${userId}`, 3600, JSON.stringify(user));\n  \n  return user;\n}\n```\n\n## Database Migration\n\n```javascript\n// Using a migration tool\nconst { Pool } = require('pg');\n\nasync function runMigrations() {\n  const pool = new Pool();\n  \n  try {\n    // Create migrations table if it doesn't exist\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS migrations (\n        id SERIAL PRIMARY KEY,\n        name VARCHAR(255) NOT NULL,\n        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n    \n    // Run migration\n    await pool.query(`\n      ALTER TABLE users ADD COLUMN IF NOT EXISTS phone VARCHAR(20)\n    `);\n    \n    await pool.query(\n      'INSERT INTO migrations (name) VALUES ($1)',\n      ['add_phone_to_users']\n    );\n  } finally {\n    await pool.end();\n  }\n}\n```\n\n## Performance Monitoring\n\n```javascript\n// Query performance monitoring\nconst { performance } = require('perf_hooks');\n\nasync function monitorQuery(query, params) {\n  const start = performance.now();\n  \n  try {\n    const result = await db.query(query, params);\n    const duration = performance.now() - start;\n    \n    if (duration > 1000) { // Log slow queries\n      console.warn(`Slow query detected: ${duration}ms`, { query, params });\n    }\n    \n    return result;\n  } catch (error) {\n    const duration = performance.now() - start;\n    console.error(`Query failed after ${duration}ms:`, error);\n    throw error;\n  }\n}\n```\n\n## Best Practices\n\n1. **Always use parameterized queries** to prevent SQL injection\n2. **Index frequently queried columns** but avoid over-indexing\n3. **Use appropriate data types** for columns\n4. **Implement proper error handling** and logging\n5. **Monitor query performance** regularly\n6. **Use connection pooling** for better resource management\n7. **Implement caching strategies** for frequently accessed data\n8. **Plan for scalability** from the beginning",
      "isNew": false,
      "isPopular": true,
      "createdAt": "2024-01-02T00:00:00Z"
    },
    {
      "id": 3,
      "title": "API Design and RESTful Services",
      "description": "Comprehensive guide to designing robust APIs, REST principles, and best practices for backend services",
      "category": "best-practices",
      "difficulty": "intermediate",
      "readTime": 18,
      "rating": 4.6,
      "reads": 756,
      "tags": ["API", "REST", "HTTP", "Design", "Microservices"],
      "content": "# API Design and RESTful Services\n\n## REST Principles\n\n### Resource-Based URLs\n```javascript\n// Good RESTful design\nGET    /api/users          // Get all users\nGET    /api/users/123      // Get specific user\nPOST   /api/users          // Create new user\nPUT    /api/users/123      // Update user (full)\nPATCH  /api/users/123      // Update user (partial)\nDELETE /api/users/123      // Delete user\n\n// Nested resources\nGET    /api/users/123/posts     // Get user's posts\nPOST   /api/users/123/posts     // Create post for user\n```\n\n### HTTP Status Codes\n```javascript\n// Success responses\nres.status(200).json({ data: users });           // OK\nres.status(201).json({ data: newUser });         // Created\nres.status(204).send();                          // No Content\n\n// Client errors\nres.status(400).json({ error: 'Bad Request' });  // Bad Request\nres.status(401).json({ error: 'Unauthorized' }); // Unauthorized\nres.status(403).json({ error: 'Forbidden' });    // Forbidden\nres.status(404).json({ error: 'Not Found' });    // Not Found\nres.status(422).json({ error: 'Validation Error' }); // Unprocessable Entity\n\n// Server errors\nres.status(500).json({ error: 'Internal Server Error' });\nres.status(503).json({ error: 'Service Unavailable' });\n```\n\n## API Response Format\n\n```javascript\n// Consistent response structure\nconst successResponse = (data, message = 'Success') => ({\n  success: true,\n  message,\n  data,\n  timestamp: new Date().toISOString()\n});\n\nconst errorResponse = (message, errors = null) => ({\n  success: false,\n  message,\n  errors,\n  timestamp: new Date().toISOString()\n});\n\n// Usage\napp.get('/api/users', async (req, res) => {\n  try {\n    const users = await User.find();\n    res.json(successResponse(users, 'Users retrieved successfully'));\n  } catch (error) {\n    res.status(500).json(errorResponse('Failed to retrieve users'));\n  }\n});\n```\n\n## Input Validation\n\n```javascript\nconst { body, param, query, validationResult } = require('express-validator');\n\n// Validation middleware\nconst validateUser = [\n  body('email').isEmail().normalizeEmail(),\n  body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/),\n  body('name').trim().isLength({ min: 2, max: 50 }),\n  body('age').isInt({ min: 18, max: 120 })\n];\n\napp.post('/api/users', validateUser, (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(422).json(errorResponse('Validation failed', errors.array()));\n  }\n  // Process valid data\n});\n```\n\n## Pagination\n\n```javascript\n// Pagination middleware\nconst paginate = (req, res, next) => {\n  const page = parseInt(req.query.page) || 1;\n  const limit = parseInt(req.query.limit) || 10;\n  const offset = (page - 1) * limit;\n  \n  req.pagination = { page, limit, offset };\n  next();\n};\n\napp.get('/api/users', paginate, async (req, res) => {\n  const { page, limit, offset } = req.pagination;\n  \n  const [users, total] = await Promise.all([\n    User.find().skip(offset).limit(limit),\n    User.countDocuments()\n  ]);\n  \n  const totalPages = Math.ceil(total / limit);\n  \n  res.json(successResponse({\n    users,\n    pagination: {\n      page,\n      limit,\n      total,\n      totalPages,\n      hasNext: page < totalPages,\n      hasPrev: page > 1\n    }\n  }));\n});\n```\n\n## Rate Limiting\n\n```javascript\nconst rateLimit = require('express-rate-limit');\n\n// Global rate limiter\nconst globalLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  message: errorResponse('Too many requests from this IP')\n});\n\n// Specific endpoint limiter\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // Limit each IP to 5 requests per windowMs\n  message: errorResponse('Too many login attempts')\n});\n\napp.use('/api/', globalLimiter);\napp.use('/api/auth/login', authLimiter);\n```\n\n## Authentication & Authorization\n\n```javascript\nconst jwt = require('jsonwebtoken');\n\n// JWT middleware\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json(errorResponse('Access token required'));\n  }\n  \n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json(errorResponse('Invalid token'));\n    }\n    req.user = user;\n    next();\n  });\n};\n\n// Role-based authorization\nconst authorize = (...roles) => {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json(errorResponse('Authentication required'));\n    }\n    \n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json(errorResponse('Insufficient permissions'));\n    }\n    \n    next();\n  };\n};\n\n// Usage\napp.get('/api/admin/users', authenticateToken, authorize('admin'), (req, res) => {\n  // Admin-only endpoint\n});\n```\n\n## API Documentation\n\n```javascript\n// Swagger/OpenAPI documentation\nconst swaggerJsdoc = require('swagger-jsdoc');\nconst swaggerUi = require('swagger-ui-express');\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'User API',\n      version: '1.0.0',\n      description: 'A simple user management API'\n    },\n    servers: [\n      {\n        url: 'http://localhost:3000',\n        description: 'Development server'\n      }\n    ]\n  },\n  apis: ['./routes/*.js']\n};\n\nconst specs = swaggerJsdoc(options);\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));\n\n/**\n * @swagger\n * /api/users:\n *   get:\n *     summary: Retrieve all users\n *     tags: [Users]\n *     parameters:\n *       - in: query\n *         name: page\n *         schema:\n *           type: integer\n *         description: Page number\n *     responses:\n *       200:\n *         description: List of users\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   type: array\n *                   items:\n *                     $ref: '#/components/schemas/User'\n */\napp.get('/api/users', async (req, res) => {\n  // Implementation\n});\n```\n\n## Error Handling\n\n```javascript\n// Global error handler\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  \n  if (err.name === 'ValidationError') {\n    return res.status(422).json(errorResponse('Validation Error', err.errors));\n  }\n  \n  if (err.name === 'CastError') {\n    return res.status(400).json(errorResponse('Invalid ID format'));\n  }\n  \n  if (err.code === 11000) {\n    return res.status(409).json(errorResponse('Duplicate entry'));\n  }\n  \n  res.status(500).json(errorResponse('Internal server error'));\n});\n\n// 404 handler\napp.use('*', (req, res) => {\n  res.status(404).json(errorResponse('Endpoint not found'));\n});\n```\n\n## API Versioning\n\n```javascript\n// URL versioning\napp.use('/api/v1', v1Routes);\napp.use('/api/v2', v2Routes);\n\n// Header versioning\nconst versionMiddleware = (req, res, next) => {\n  const version = req.headers['api-version'] || '1.0';\n  req.apiVersion = version;\n  next();\n};\n\napp.use(versionMiddleware);\n\napp.get('/api/users', (req, res) => {\n  if (req.apiVersion === '2.0') {\n    // Return enhanced user data\n    return res.json(enhancedUserResponse);\n  }\n  // Return basic user data\n  res.json(basicUserResponse);\n});\n```\n\n## Testing APIs\n\n```javascript\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('User API', () => {\n  describe('GET /api/users', () => {\n    it('should return all users', async () => {\n      const response = await request(app)\n        .get('/api/users')\n        .expect(200);\n      \n      expect(response.body.success).toBe(true);\n      expect(Array.isArray(response.body.data)).toBe(true);\n    });\n    \n    it('should handle pagination', async () => {\n      const response = await request(app)\n        .get('/api/users?page=1&limit=5')\n        .expect(200);\n      \n      expect(response.body.data.pagination.page).toBe(1);\n      expect(response.body.data.pagination.limit).toBe(5);\n    });\n  });\n  \n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'Password123'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(201);\n      \n      expect(response.body.success).toBe(true);\n      expect(response.body.data.email).toBe(userData.email);\n    });\n  });\n});\n```\n\n## Best Practices Summary\n\n1. **Use consistent naming conventions** for endpoints\n2. **Implement proper HTTP status codes**\n3. **Validate all inputs** thoroughly\n4. **Use pagination** for large datasets\n5. **Implement rate limiting** to prevent abuse\n6. **Use HTTPS** in production\n7. **Document your APIs** with OpenAPI/Swagger\n8. **Version your APIs** for backward compatibility\n9. **Handle errors gracefully** with meaningful messages\n10. **Test your APIs** thoroughly",
      "isNew": false,
      "isPopular": true,
      "createdAt": "2024-01-03T00:00:00Z"
    }
  ]
}
