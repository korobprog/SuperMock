{
  "profession": "fullstack-developer",
  "language": "es",
  "categories": [
    {
      "id": "interview-questions",
      "name": "Preguntas de Entrevista",
      "count": 156,
      "icon": "üí¨",
      "color": "bg-blue-100 text-blue-800"
    },
    {
      "id": "technical-tasks",
      "name": "Tareas T√©cnicas",
      "count": 89,
      "icon": "‚ö°",
      "color": "bg-green-100 text-green-800"
    },
    {
      "id": "system-design",
      "name": "Dise√±o de Sistemas",
      "count": 34,
      "icon": "üèóÔ∏è",
      "color": "bg-purple-100 text-purple-800"
    },
    {
      "id": "behavioral",
      "name": "Preguntas de Comportamiento",
      "count": 67,
      "icon": "üß†",
      "color": "bg-orange-100 text-orange-800"
    },
    {
      "id": "algorithms",
      "name": "Algoritmos y Estructuras de Datos",
      "count": 123,
      "icon": "üìä",
      "color": "bg-red-100 text-red-800"
    },
    {
      "id": "best-practices",
      "name": "Mejores Pr√°cticas",
      "count": 78,
      "icon": "‚≠ê",
      "color": "bg-yellow-100 text-yellow-800"
    }
  ],
  "materials": [
    {
      "id": 1,
      "title": "Desarrollo Fullstack: Del Concepto al Despliegue",
      "description": "Gu√≠a completa de desarrollo fullstack incluyendo pr√°cticas de frontend, backend y DevOps",
      "category": "interview-questions",
      "difficulty": "intermediate",
      "readTime": 25,
      "rating": 4.9,
      "reads": 1345,
      "tags": ["Fullstack", "Frontend", "Backend", "DevOps", "Arquitectura"],
      "content": "# Desarrollo Fullstack: Del Concepto al Despliegue\n\n## Introducci√≥n\n\nUn desarrollador fullstack es un especialista que puede trabajar tanto con las partes frontend como backend de una aplicaci√≥n, as√≠ como entender los procesos de despliegue y DevOps.\n\n## Arquitectura de Aplicaci√≥n Fullstack\n\n```javascript\n// Estructura del proyecto\nproject/\n‚îú‚îÄ‚îÄ frontend/          # Aplicaci√≥n React/Vue/Angular\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ public/\n‚îÇ   ‚îî‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ backend/           # Servidor Node.js/Python/Java\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ routes/\n‚îÇ   ‚îî‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ database/          # Esquemas y migraciones\n‚îú‚îÄ‚îÄ docker/           # Configuraci√≥n Docker\n‚îî‚îÄ‚îÄ docs/             # Documentaci√≥n\n```\n\n## Frontend (React + TypeScript)\n\n```typescript\n// Componente con TypeScript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface UserListProps {\n  users: User[];\n  onUserSelect: (user: User) => void;\n}\n\nconst UserList: React.FC<UserListProps> = ({ users, onUserSelect }) => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleUserClick = async (user: User) => {\n    try {\n      setLoading(true);\n      await onUserSelect(user);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"user-list\">\n      {users.map(user => (\n        <div key={user.id} onClick={() => handleUserClick(user)}>\n          <h3>{user.name}</h3>\n          <p>{user.email}</p>\n        </div>\n      ))}\n    </div>\n  );\n};\n```\n\n## Backend (Node.js + Express)\n\n```javascript\n// Servidor API con Express\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\n// Middleware\napp.use(helmet());\napp.use(cors({\n  origin: process.env.FRONTEND_URL,\n  credentials: true\n}));\n\n// Limitaci√≥n de velocidad\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutos\n  max: 100 // m√°ximo 100 solicitudes\n});\napp.use('/api/', limiter);\n\n// Rutas\napp.use('/api/users', require('./routes/users'));\napp.use('/api/auth', require('./routes/auth'));\napp.use('/api/products', require('./routes/products'));\n\n// Manejo de errores\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: 'Error interno del servidor' });\n});\n\nmodule.exports = app;\n```\n\n## Base de Datos (PostgreSQL + Prisma)\n\n```javascript\n// Esquema Prisma\n// prisma/schema.prisma\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  password  String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  posts     Post[]\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String\n  published Boolean  @default(false)\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n```\n\n## Integraci√≥n API\n\n```typescript\n// Cliente API\nclass ApiClient {\n  private baseURL: string;\n  private token: string | null = null;\n\n  constructor(baseURL: string) {\n    this.baseURL = baseURL;\n  }\n\n  setToken(token: string) {\n    this.token = token;\n  }\n\n  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const url = `${this.baseURL}${endpoint}`;\n    const config: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(this.token && { Authorization: `Bearer ${this.token}` }),\n        ...options.headers,\n      },\n      ...options,\n    };\n\n    const response = await fetch(url, config);\n\n    if (!response.ok) {\n      throw new Error(`Error HTTP! estado: ${response.status}`);\n    }\n\n    return response.json();\n  }\n\n  // API de Usuarios\n  async getUsers(): Promise<User[]> {\n    return this.request<User[]>('/api/users');\n  }\n\n  async createUser(userData: Omit<User, 'id'>): Promise<User> {\n    return this.request<User>('/api/users', {\n      method: 'POST',\n      body: JSON.stringify(userData),\n    });\n  }\n\n  // API de Autenticaci√≥n\n  async login(credentials: { email: string; password: string }): Promise<{ token: string }> {\n    const result = await this.request<{ token: string }>('/api/auth/login', {\n      method: 'POST',\n      body: JSON.stringify(credentials),\n    });\n    this.setToken(result.token);\n    return result;\n  }\n}\n\n// Uso\nconst api = new ApiClient('http://localhost:3000');\n```\n\n## Gesti√≥n de Estado (Redux Toolkit)\n\n```typescript\n// Store Redux\nimport { configureStore } from '@reduxjs/toolkit';\nimport authReducer from './slices/authSlice';\nimport usersReducer from './slices/usersSlice';\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    users: usersReducer,\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: ['persist/PERSIST'],\n      },\n    }),\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// Slice de autenticaci√≥n\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { api } from '../services/api';\n\ninterface AuthState {\n  user: User | null;\n  token: string | null;\n  loading: boolean;\n  error: string | null;\n}\n\nconst initialState: AuthState = {\n  user: null,\n  token: localStorage.getItem('token'),\n  loading: false,\n  error: null,\n};\n\nexport const login = createAsyncThunk(\n  'auth/login',\n  async (credentials: { email: string; password: string }) => {\n    const response = await api.login(credentials);\n    return response;\n  }\n);\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    logout: (state) => {\n      state.user = null;\n      state.token = null;\n      localStorage.removeItem('token');\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(login.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(login.fulfilled, (state, action) => {\n        state.loading = false;\n        state.token = action.payload.token;\n        localStorage.setItem('token', action.payload.token);\n      })\n      .addCase(login.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message || 'Error de inicio de sesi√≥n';\n      });\n  },\n});\n\nexport const { logout } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n## Docker y Despliegue\n\n```dockerfile\n# Dockerfile para frontend\nFROM node:18-alpine as build\n\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\nRUN npm run build\n\nFROM nginx:alpine\nCOPY --from=build /app/build /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/nginx.conf\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:80\"\n    depends_on:\n      - backend\n    environment:\n      - REACT_APP_API_URL=http://localhost:3001\n\n  backend:\n    build: ./backend\n    ports:\n      - \"3001:3001\"\n    depends_on:\n      - postgres\n      - redis\n    environment:\n      - DATABASE_URL=postgresql://user:password@postgres:5432/myapp\n      - REDIS_URL=redis://redis:6379\n      - JWT_SECRET=your-secret-key\n\n  postgres:\n    image: postgres:15\n    environment:\n      - POSTGRES_DB=myapp\n      - POSTGRES_USER=user\n      - POSTGRES_PASSWORD=password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n\nvolumes:\n  postgres_data:\n```\n\n## Pipeline CI/CD\n\n```yaml\n# .github/workflows/deploy.yml\nname: Desplegar a Producci√≥n\n\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Configurar Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - name: Instalar dependencias\n        run: |\n          cd frontend && npm ci\n          cd ../backend && npm ci\n      \n      - name: Ejecutar tests\n        run: |\n          cd frontend && npm test\n          cd ../backend && npm test\n      \n      - name: Construir\n        run: |\n          cd frontend && npm run build\n          cd ../backend && npm run build\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Desplegar al servidor\n        run: |\n          # Comandos SSH para despliegue\n          ssh user@server 'cd /app && git pull && docker-compose up -d'\n```\n\n## Monitoreo y Logging\n\n```javascript\n// Logger Winston\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  defaultMeta: { service: 'fullstack-app' },\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' }),\n  ],\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  logger.add(new winston.transports.Console({\n    format: winston.format.simple()\n  }));\n}\n\n// Uso\nlogger.info('Aplicaci√≥n iniciada', { port: process.env.PORT });\nlogger.error('Error de base de datos', { error: err.message });\n```\n\n## Testing\n\n```typescript\n// Jest + React Testing Library\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { Provider } from 'react-redux';\nimport { store } from '../store';\nimport UserList from './UserList';\n\nconst mockUsers = [\n  { id: 1, name: 'Juan', email: 'juan@example.com' },\n  { id: 2, name: 'Mar√≠a', email: 'maria@example.com' }\n];\n\nconst mockOnUserSelect = jest.fn();\n\ndescribe('UserList', () => {\n  it('muestra lista de usuarios', () => {\n    render(\n      <Provider store={store}>\n        <UserList users={mockUsers} onUserSelect={mockOnUserSelect} />\n      </Provider>\n    );\n\n    expect(screen.getByText('Juan')).toBeInTheDocument();\n    expect(screen.getByText('Mar√≠a')).toBeInTheDocument();\n  });\n\n  it('llama a onUserSelect al hacer clic en usuario', async () => {\n    render(\n      <Provider store={store}>\n        <UserList users={mockUsers} onUserSelect={mockOnUserSelect} />\n      </Provider>\n    );\n\n    fireEvent.click(screen.getByText('Juan'));\n\n    await waitFor(() => {\n      expect(mockOnUserSelect).toHaveBeenCalledWith(mockUsers[0]);\n    });\n  });\n});\n```\n\n## Mejores Pr√°cticas\n\n1. **Separaci√≥n de Responsabilidades**: Separar claramente la l√≥gica frontend y backend\n2. **Seguridad de Tipos**: Usar TypeScript para mejor experiencia de desarrollo\n3. **Seguridad**: Validar datos en todos los niveles\n4. **Rendimiento**: Optimizar consultas y cach√©\n5. **Escalabilidad**: Dise√±ar pensando en el crecimiento\n6. **Monitoreo**: Rastrear rendimiento y errores\n7. **Documentaci√≥n**: Mantener documentaci√≥n actualizada\n8. **Testing**: Cubrir c√≥digo con tests\n\n## Conclusi√≥n\n\nEl desarrollo fullstack requiere comprensi√≥n profunda de todas las capas de la aplicaci√≥n. Un desarrollador fullstack exitoso debe poder trabajar efectivamente con frontend, backend e infraestructura.",
      "isNew": false,
      "isPopular": true,
      "createdAt": "2024-01-01T00:00:00Z"
    }
  ]
}
