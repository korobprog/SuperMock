#!/usr/bin/env bash

set -Eeuo pipefail

# ============================================================================
# SuperMock Production Deploy Script v2.0
# ============================================================================
# Enhanced deployment script with better error handling, logging, and features
# Usage: 
#   SERVER=217.198.6.238 DEST=/opt/mockmate bash scripts/deploy-quick.sh
#   bash scripts/deploy-quick.sh --help

# Color codes for better output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
SERVER="${SERVER:-217.198.6.238}"
USER_="${USER_:-root}"
DEST="${DEST:-/opt/mockmate}"
COMPOSE_FILE="${COMPOSE_FILE:-docker-compose.prod.yml}"
SSH_KEY="${SSH_KEY:-~/.ssh/timeweb_vps_key}"
LOG_FILE="${LOG_FILE:-deploy-$(date +%Y%m%d-%H%M%S).log}"
TIMEOUT="${TIMEOUT:-300}"
RETRY_COUNT="${RETRY_COUNT:-3}"

# Domains for testing
FRONTEND_DOMAIN="${FRONTEND_DOMAIN:-supermock.ru}"
BACKEND_DOMAIN="${BACKEND_DOMAIN:-api.supermock.ru}"

# Enhanced helper functions
print() { printf "%s\n" "$*"; }
step() { printf "\n${BLUE}==== %s ====${NC}\n" "$*"; }
success() { printf "${GREEN}‚úÖ %s${NC}\n" "$*"; }
error() { printf "${RED}‚ùå %s${NC}\n" "$*"; }
warning() { printf "${YELLOW}‚ö†Ô∏è  %s${NC}\n" "$*"; }
info() { printf "${CYAN}‚ÑπÔ∏è  %s${NC}\n" "$*"; }

# Logging and error handling
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

cleanup() {
    if [[ $? -ne 0 ]]; then
        error "Script failed! Check log file: $LOG_FILE"
        warning "Last 10 lines of log:"
        tail -10 "$LOG_FILE" 2>/dev/null || true
    fi
}
trap cleanup EXIT

# Validation functions
validate_ssh_key() {
    if [[ ! -f "$SSH_KEY" ]]; then
        error "SSH key not found: $SSH_KEY"
        info "Create SSH key with: ssh-keygen -t rsa -b 2048 -f $SSH_KEY"
        exit 1
    fi
    
    if [[ "$(stat -c %a "$SSH_KEY" 2>/dev/null || stat -f %A "$SSH_KEY" 2>/dev/null)" != "600" ]]; then
        warning "SSH key permissions are not secure. Fixing..."
        chmod 600 "$SSH_KEY"
        success "SSH key permissions fixed"
    fi
}

validate_connection() {
    info "Testing SSH connection to ${USER_}@${SERVER}..."
    if ! ssh -i "${SSH_KEY}" -o ConnectTimeout=10 -o StrictHostKeyChecking=no "${USER_}@${SERVER}" "echo 'Connection OK'" >/dev/null 2>&1; then
        error "Cannot connect to ${USER_}@${SERVER}"
        error "Check if:"
        error "  1. Server is running and accessible"
        error "  2. SSH key is correct and has proper permissions"
        error "  3. User has access to the server"
        exit 1
    fi
    success "SSH connection validated"
}

# Enhanced sync function
enhanced_sync() {
    local description="${1:-Full sync}"
    step "$description"
    
    info "Syncing from $(pwd) to ${USER_}@${SERVER}:${DEST}"
    
    rsync -az \
        --delete \
        --progress \
        --human-readable \
        --exclude='.git' \
        --exclude='.github' \
        --exclude='.pnpm-store' \
        --exclude='**/node_modules' \
        --exclude='**/.next' \
        --exclude='**/dist' \
        --exclude='*.log' \
        --exclude='.env.local' \
        -e "ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no" \
        ./ "${USER_}@${SERVER}:${DEST}/" 2>&1 | tee -a "$LOG_FILE"
    
    if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
        success "Sync completed successfully"
    else
        error "Sync failed"
        return 1
    fi
}

# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–π —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –Ω–∏–∂–µ

# Enhanced remote execution with retry and timeout
run_remote() {
    local cmd="$1"
    local description="${2:-Remote command}"
    local retries="${3:-$RETRY_COUNT}"
    
    log "$description: $cmd"
    
    for ((i=1; i<=retries; i++)); do
        if [[ $i -gt 1 ]]; then
            info "Executing: $description (attempt $i/$retries)"
        fi
        
        if timeout "$TIMEOUT" ssh -i "${SSH_KEY}" -o StrictHostKeyChecking=no "${USER_}@${SERVER}" bash -lc "$cmd" 2>&1 | tee -a "$LOG_FILE"; then
            success "$description completed"
            return 0
        else
            local exit_code=$?
            if [[ $i -eq $retries ]]; then
                error "$description failed after $retries attempts (exit code: $exit_code)"
                return $exit_code
            else
                warning "$description failed (attempt $i/$retries), retrying in 5 seconds..."
                sleep 5
            fi
        fi
    done
}

# Service health checks
check_service_health() {
    local service="$1"
    local url="$2"
    local expected="${3:-200}"
    
    info "Checking $service health..."
    
    local http_code
    http_code=$(curl -s -w "%{http_code}" -o /dev/null --connect-timeout 10 --max-time 30 "$url" 2>/dev/null || echo "000")
    
    if [[ "$http_code" == "$expected" ]]; then
        success "$service is healthy (HTTP $http_code)"
        return 0
    else
        warning "$service health check failed (HTTP $http_code)"
        return 1
    fi
}

# Deploy functions
deploy_full() {
    step "üöÄ Full Application Deployment"
    enhanced_sync "Full application sync"
    
    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    info "Checking database health before deployment..."
    local db_healthy=false
    if run_remote "cd '${DEST}' && docker compose -f '${COMPOSE_FILE}' exec -T postgres psql -U supermock -d supermock -c 'SELECT 1;' >/dev/null 2>&1" "Database health check" 1; then
        db_healthy=true
        success "Database is healthy"
    else
        warning "Database is not accessible, will need to recreate"
    fi
    
    # –°–æ–∑–¥–∞–µ–º —Å–µ—Ç—å Traefik
    run_remote "cd '${DEST}' && \
        echo '-- Creating traefik network if needed --' && \
        docker network inspect traefik-network >/dev/null 2>&1 || docker network create traefik-network" "Creating Traefik network"
    
    # –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–µ–ø–ª–æ–π —Å –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏
    if $db_healthy; then
        # –ë–∞–∑–∞ –∑–¥–æ—Ä–æ–≤–∞ - –æ–±–Ω–æ–≤–ª—è–µ–º —Å–µ—Ä–≤–∏—Å—ã –±–µ–∑ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è –ë–î
        run_remote "cd '${DEST}' && \
            echo '-- Building services (preserving database) --' && \
            docker compose -f '${COMPOSE_FILE}' build --pull frontend backend && \
            echo '-- Restarting services safely --' && \
            docker compose -f '${COMPOSE_FILE}' up -d --no-recreate postgres redis && \
            docker compose -f '${COMPOSE_FILE}' up -d backend frontend turn && \
            echo '-- Waiting for services to be healthy --' && \
            sleep 15" "Safe deployment (preserving database)"
    else
        # –ë–∞–∑–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ - –ø–æ–ª–Ω–æ–µ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ —Å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º
        warning "Performing full deployment with database recreation"
        run_remote "cd '${DEST}' && \
            echo '-- Building all services --' && \
            docker compose -f '${COMPOSE_FILE}' build --pull && \
            echo '-- Starting all services --' && \
            docker compose -f '${COMPOSE_FILE}' up -d && \
            echo '-- Waiting for PostgreSQL to be ready --' && \
            sleep 10 && \
            echo '-- Setting up database schema --' && \
            docker compose -f '${COMPOSE_FILE}' exec -T backend pnpm exec prisma db push --accept-data-loss && \
            echo '-- Waiting for all services to be healthy --' && \
            sleep 15" "Full deployment with database setup"
    fi
    
    comprehensive_health_check
}

deploy_backend() {
    step "üîß Backend Deployment"
    enhanced_sync "Backend sync"
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º backend
    info "Checking database connectivity..."
    if ! run_remote "cd '${DEST}' && docker compose -f '${COMPOSE_FILE}' exec -T postgres psql -U supermock -d supermock -c 'SELECT 1;' >/dev/null 2>&1" "Database connectivity check" 1; then
        warning "Database not accessible, ensuring it's running..."
        run_remote "cd '${DEST}' && docker compose -f '${COMPOSE_FILE}' up -d postgres && sleep 10" "Starting PostgreSQL"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω—É–∂–Ω–∞ –ª–∏ —Å—Ö–µ–º–∞
        if ! run_remote "cd '${DEST}' && docker compose -f '${COMPOSE_FILE}' exec -T postgres psql -U supermock -d supermock -c '\dt' | grep -q 'User'" "Schema check" 1; then
            info "Database schema missing, creating..."
            run_remote "cd '${DEST}' && docker compose -f '${COMPOSE_FILE}' exec -T backend pnpm exec prisma db push --accept-data-loss" "Creating database schema"
        fi
    fi
    
    run_remote "cd '${DEST}' && \
        docker compose -f '${COMPOSE_FILE}' build --pull backend && \
        docker compose -f '${COMPOSE_FILE}' up -d --no-deps backend && \
        echo 'Waiting for backend to be healthy...' && \
        for i in {1..60}; do \
            if docker exec supermock-backend sh -lc 'wget -qO- http://127.0.0.1:3000/api/health >/dev/null 2>&1'; then \
                echo 'Backend is healthy!'; break; \
            else \
                echo 'Waiting for backend... (\$i/60)'; sleep 2; \
            fi; \
        done" "Backend build and deploy"
    
    check_service_health "Backend API" "https://$BACKEND_DOMAIN/api/health"
}

deploy_frontend() {
    step "üé® Frontend Deployment"
    enhanced_sync "Frontend sync"
    
    # –£–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ backend —Ä–∞–±–æ—Ç–∞–µ—Ç (frontend –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –Ω–µ–≥–æ)
    info "Checking backend dependency..."
    if ! run_remote "cd '${DEST}' && docker exec supermock-backend sh -lc 'wget -qO- http://127.0.0.1:3000/api/health >/dev/null 2>&1'" "Backend availability check" 1; then
        warning "Backend not responding, starting it first..."
        run_remote "cd '${DEST}' && docker compose -f '${COMPOSE_FILE}' up -d backend && sleep 10" "Starting backend"
    fi
    
    run_remote "cd '${DEST}' && \
        docker compose -f '${COMPOSE_FILE}' build --no-cache frontend && \
        docker compose -f '${COMPOSE_FILE}' up -d --no-deps frontend && \
        echo 'Waiting for frontend to be ready...' && \
        sleep 10 && \
        docker exec supermock-frontend sh -lc 'wget -qO- http://127.0.0.1:8080/ >/dev/null 2>&1 && echo \"Frontend OK\" || echo \"Frontend FAIL\"'" "Frontend build and deploy"
    
    check_service_health "Frontend" "https://$FRONTEND_DOMAIN"
}

comprehensive_health_check() {
    step "üè• Comprehensive Health Check"
    
    # Container status
    info "Checking container status..."
    run_remote "cd '${DEST}' && docker compose -f '${COMPOSE_FILE}' ps --format table" "Container status"
    
    # Internal health checks
    info "Internal service health checks..."
    run_remote "cd '${DEST}' && \
        echo '-- Backend internal health --' && \
        docker exec supermock-backend sh -lc 'wget -qO- http://127.0.0.1:3000/api/health' 2>/dev/null | jq . || echo 'Backend internal FAIL' && \
        echo '-- Frontend internal health --' && \
        docker exec supermock-frontend sh -lc 'wget -qO- http://127.0.0.1:8080/health' 2>/dev/null || echo 'Frontend internal FAIL' && \
        echo '-- Frontend ‚Üí Backend proxy --' && \
        docker exec supermock-frontend sh -lc 'wget -qO- http://127.0.0.1:8080/api/health' 2>/dev/null | jq . || echo 'Frontend proxy FAIL'" "Internal health checks"
    
    # External health checks
    info "External health checks..."
    if check_service_health "Frontend" "https://$FRONTEND_DOMAIN"; then
        success "Frontend externally accessible"
    else
        error "Frontend not accessible externally"
    fi
    
    if check_service_health "Backend API" "https://$BACKEND_DOMAIN/api/health"; then
        success "Backend API externally accessible"
    else
        error "Backend API not accessible externally"
    fi
    
    success "Health check completed"
}

check_turn_server() {
    step "üåê TURN Server Check"
    
    run_remote "cd '${DEST}' && \
        echo '-- TURN container status --' && \
        docker ps | grep -i turn || echo 'TURN container not found' && \
        echo '-- TURN container logs (last 20 lines) --' && \
        docker logs --tail=20 supermock-turn 2>&1 || echo 'TURN logs unavailable' && \
        echo '-- Port connectivity tests --' && \
        timeout 3 bash -c '</dev/tcp/127.0.0.1/3478' && echo '3478/tcp OK' || echo '3478/tcp FAIL' && \
        timeout 3 bash -c '</dev/tcp/127.0.0.1/5349' && echo '5349/tcp OK' || echo '5349/tcp FAIL'" "TURN server check"
}

show_environment() {
    step "üîë Environment Variables"
    
    run_remote "cd '${DEST}' && \
        echo '-- Environment file status --' && \
        ls -la .env* 2>/dev/null || echo 'No .env files found' && \
        echo '-- Key environment variables --' && \
        [ -f .env ] && grep -E '^(TELEGRAM_BOT_TOKEN|VITE_TELEGRAM_BOT_NAME|VITE_TELEGRAM_BOT_ID|FRONTEND_URL|BACKEND_URL|VITE_API_URL|ENABLE_DEMO_MODE)=' .env | sed 's/=.*/=***/' || echo 'No .env file'" "Environment check"
}

full_diagnostic() {
    step "üîç Full System Diagnostic"
    
    run_remote "cd '${DEST}' && \
        echo '=== SYSTEM INFO ===' && \
        echo '-- OS Info --' && uname -a && \
        echo '-- Docker Version --' && docker --version && docker compose version && \
        echo '-- Available Space --' && df -h && \
        echo '-- Memory Usage --' && free -h && \
        echo '-- System Load --' && uptime && \
        echo && echo '=== DOCKER STATUS ===' && \
        echo '-- All Containers --' && docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' && \
        echo '-- Docker Compose Status --' && docker compose -f '${COMPOSE_FILE}' ps && \
        echo '-- Docker Networks --' && docker network ls && \
        echo && echo '=== SERVICE LOGS ===' && \
        echo '-- Backend Logs (last 15 lines) --' && docker logs supermock-backend --tail=15 2>&1 && \
        echo '-- Frontend Logs (last 15 lines) --' && docker logs supermock-frontend --tail=15 2>&1 && \
        echo '-- Traefik Logs (last 15 lines) --' && docker logs traefik --tail=15 2>&1 && \
        echo && echo '=== NETWORK STATUS ===' && \
        echo '-- Open Ports --' && ss -tlnp | grep -E ':(80|443|3000|3478|5349|8080)' && \
        echo '-- Traefik Network Inspect --' && docker network inspect traefik-network | grep -A3 -B3 supermock || echo 'No supermock containers in traefik network' && \
        echo && echo '=== END DIAGNOSTIC ==='" "Full diagnostic"
}

quick_restart() {
    step "üîÑ Quick Service Restart"
    
    run_remote "cd '${DEST}' && \
        echo '-- Restarting all services --' && \
        docker compose -f '${COMPOSE_FILE}' restart && \
        echo '-- Waiting for services to stabilize --' && \
        sleep 10 && \
        docker compose -f '${COMPOSE_FILE}' ps" "Quick restart"
}

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
fix_database() {
    step "üîß Database Recovery"
    
    warning "This will recreate the database and lose all data!"
    printf "${YELLOW}Are you sure? [y/N]:${NC} "
    read -r confirm
    
    if [[ $confirm =~ ^[Yy]$ ]]; then
        run_remote "cd '${DEST}' && \
            echo '-- Stopping services --' && \
            docker compose -f '${COMPOSE_FILE}' down && \
            echo '-- Removing database volume --' && \
            docker volume rm mockmate_postgres_data || true && \
            echo '-- Starting database --' && \
            docker compose -f '${COMPOSE_FILE}' up -d postgres && \
            echo '-- Waiting for PostgreSQL --' && \
            sleep 15 && \
            echo '-- Starting backend --' && \
            docker compose -f '${COMPOSE_FILE}' up -d backend && \
            echo '-- Creating schema --' && \
            docker compose -f '${COMPOSE_FILE}' exec -T backend pnpm exec prisma db push --accept-data-loss && \
            echo '-- Starting all services --' && \
            docker compose -f '${COMPOSE_FILE}' up -d" "Database recovery"
        
        success "Database recovery completed"
        comprehensive_health_check
    else
        info "Database recovery cancelled"
    fi
}

# Pre-flight checks and main execution
info "Starting SuperMock Deploy Script v2.0"
log "Deploy started by $(whoami) at $(date)"
validate_ssh_key
validate_connection

# Main loop
while true; do
    step "üöÄ SuperMock Deploy Console"
    print "${PURPLE}Deploy target:${NC} ${USER_}@${SERVER}:${DEST}"
    print "${PURPLE}SSH Key:${NC} ${SSH_KEY}"
    print "${PURPLE}Log File:${NC} ${LOG_FILE}"
    print ""
    print "Select deployment action:"
    print "  ${GREEN}1)${NC} üöÄ Full Deploy (Sync + Build all + Up + Tests)"
    print "  ${GREEN}2)${NC} üîß Backend only (Sync + Build + Up)"
    print "  ${GREEN}3)${NC} üé® Frontend only (Sync + Build + Up)"
    print "  ${GREEN}4)${NC} üìä Database update (Prisma migrate)"
    print "  ${GREEN}5)${NC} ‚ù§Ô∏è  Health check (all services)"
    print "  ${GREEN}6)${NC} üåê TURN server check"
    print "  ${GREEN}7)${NC} üîë Show environment variables"
    print "  ${GREEN}8)${NC} üîç Full diagnostic (logs + status)"
    print "  ${GREEN}9)${NC} üîÑ Quick restart all services"
    print "  ${YELLOW}10)${NC} üîß Fix database (recreate with schema)"
    print "  ${RED}0)${NC} üö™ Exit"
    printf "\n${YELLOW}Choice [1-10, 0]:${NC} "
    read -r choice

case "${choice}" in
  1) deploy_full
    ;;
  2) deploy_backend
    ;;
  3) deploy_frontend
    ;;
  4) 
    step "üìä Database Update"
    run_remote "cd '${DEST}' && \
        echo '-- Running Prisma migrations --' && \
        (docker compose -f '${COMPOSE_FILE}' exec -T backend pnpm exec prisma migrate deploy || \
         docker compose -f '${COMPOSE_FILE}' exec -T backend pnpm exec prisma db push) && \
        echo '-- Generating Prisma client --' && \
        docker compose -f '${COMPOSE_FILE}' exec -T backend pnpm exec prisma generate" "Database migration"
    ;;
  5) comprehensive_health_check
    ;;
  6) check_turn_server
    ;;
  7) show_environment
    ;;
  8) full_diagnostic
    ;;
  9) quick_restart
    ;;
  10) fix_database
    ;;
  0) 
    success "Goodbye! üëã"
    log "Deploy script completed successfully"
    exit 0 
    ;;
  *) 
    error "Invalid choice: $choice"
    warning "Please select a number between 0-10"
    ;;
esac

print "\n${CYAN}Press Enter to continue...${NC}"
read -r
done


