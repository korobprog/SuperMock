const { PrismaClient } = require('@prisma/client');
const fs = require('fs');
const path = require('path');

const prisma = new PrismaClient();

// –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —è–∑—ã–∫–∏
const SUPPORTED_LANGUAGES = ['ru', 'en', 'es', 'de', 'fr', 'zh'];

// –ü—Ä–æ—Ñ–µ—Å—Å–∏–∏
const PROFESSIONS = [
  'frontend-developer',
  'backend-developer',
  'fullstack-developer',
  'mobile-developer',
  'devops-engineer',
  'qa-engineer',
  'ux-ui-designer',
  'data-analyst',
  'data-scientist',
  'product-manager'
];

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏
async function createBackup() {
  console.log('üíæ Creating backup...');
  
  try {
    const materials = await prisma.material.findMany({
      include: {
        translations: true
      }
    });

    const backupData = {
      timestamp: new Date().toISOString(),
      materials: materials
    };

    const backupDir = path.join(__dirname, '..', 'backups');
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }

    const backupFile = path.join(backupDir, `materials-backup-${Date.now()}.json`);
    fs.writeFileSync(backupFile, JSON.stringify(backupData, null, 2));
    
    console.log(`‚úÖ Backup created: ${backupFile}`);
    return backupFile;
  } catch (error) {
    console.error('‚ùå Error creating backup:', error);
    return null;
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ JSON —Ñ–∞–π–ª–æ–≤
async function validateJsonFiles() {
  console.log('üîç Validating JSON files...');
  
  const errors = [];
  const validFiles = [];

  for (const profession of PROFESSIONS) {
    for (const language of SUPPORTED_LANGUAGES) {
      const filePath = path.join(__dirname, '..', 'materials', `${profession}-${language}.json`);
      
      if (fs.existsSync(filePath)) {
        try {
          const content = fs.readFileSync(filePath, 'utf8');
          const data = JSON.parse(content);
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É
          if (!data.profession || !data.language || !Array.isArray(data.materials)) {
            errors.push(`${filePath}: Invalid structure`);
          } else {
            validFiles.push(filePath);
            console.log(`‚úÖ ${filePath}`);
          }
        } catch (error) {
          errors.push(`${filePath}: ${error.message}`);
        }
      }
    }
  }

  if (errors.length > 0) {
    console.log('\n‚ùå Validation errors:');
    errors.forEach(error => console.log(`  ${error}`));
    return false;
  }

  console.log(`\n‚úÖ Validation completed: ${validFiles.length} valid files`);
  return true;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —á–∞—Å—Ç–∏—á–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤
async function updateMaterials(profession = null, language = null) {
  console.log('üîÑ Starting materials update...');

  try {
    // –°–æ–∑–¥–∞–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é
    await createBackup();

    let updatedCount = 0;
    let createdCount = 0;

    const professionsToUpdate = profession ? [profession] : PROFESSIONS;
    const languagesToUpdate = language ? [language] : SUPPORTED_LANGUAGES;

    for (const prof of professionsToUpdate) {
      console.log(`\nüìö Processing ${prof}...`);

      for (const lang of languagesToUpdate) {
        const filePath = path.join(__dirname, '..', 'materials', `${prof}-${lang}.json`);
        
        if (!fs.existsSync(filePath)) {
          console.log(`‚ö†Ô∏è  File not found: ${filePath}`);
          continue;
        }

        const materialsData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
        console.log(`  üìñ Processing ${materialsData.materials?.length || 0} materials for ${lang}`);

        for (const materialData of materialsData.materials || []) {
          try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –º–∞—Ç–µ—Ä–∏–∞–ª
            const existingMaterial = await prisma.material.findFirst({
              where: {
                profession: materialsData.profession,
                category: materialData.category,
                difficulty: materialData.difficulty,
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º title –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
                translations: {
                  some: {
                    title: materialData.title,
                    language: materialsData.language
                  }
                }
              },
              include: {
                translations: true
              }
            });

            if (existingMaterial) {
              // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –º–∞—Ç–µ—Ä–∏–∞–ª
              await prisma.material.update({
                where: { id: existingMaterial.id },
                data: {
                  readTime: materialData.readTime,
                  rating: materialData.rating,
                  reads: materialData.reads,
                  tags: materialData.tags,
                  isNew: materialData.isNew,
                  isPopular: materialData.isPopular,
                  updatedAt: new Date(),
                }
              });

              // –û–±–Ω–æ–≤–ª—è–µ–º –ø–µ—Ä–µ–≤–æ–¥
              const existingTranslation = existingMaterial.translations.find(
                t => t.language === materialsData.language
              );

              if (existingTranslation) {
                await prisma.materialTranslation.update({
                  where: { id: existingTranslation.id },
                  data: {
                    title: materialData.title,
                    description: materialData.description,
                    content: materialData.content,
                    updatedAt: new Date(),
                  }
                });
              } else {
                // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø–µ—Ä–µ–≤–æ–¥
                await prisma.materialTranslation.create({
                  data: {
                    materialId: existingMaterial.id,
                    language: materialsData.language,
                    title: materialData.title,
                    description: materialData.description,
                    content: materialData.content,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                  }
                });
              }

              updatedCount++;
              console.log(`    üîÑ Updated: ${materialData.title} (${lang})`);

            } else {
              // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª
              const material = await prisma.material.create({
                data: {
                  profession: materialsData.profession,
                  category: materialData.category,
                  difficulty: materialData.difficulty,
                  readTime: materialData.readTime,
                  rating: materialData.rating,
                  reads: materialData.reads,
                  tags: materialData.tags,
                  isNew: materialData.isNew,
                  isPopular: materialData.isPopular,
                  createdAt: new Date(materialData.createdAt),
                  updatedAt: new Date(),
                }
              });

              // –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥
              await prisma.materialTranslation.create({
                data: {
                  materialId: material.id,
                  language: materialsData.language,
                  title: materialData.title,
                  description: materialData.description,
                  content: materialData.content,
                  createdAt: new Date(),
                  updatedAt: new Date(),
                }
              });

              createdCount++;
              console.log(`    ‚úÖ Created: ${materialData.title} (${lang})`);
            }

          } catch (error) {
            console.error(`    ‚ùå Error processing ${materialData.title}:`, error.message);
          }
        }
      }
    }

    console.log(`\nüéâ Update completed!`);
    console.log(`üìä Materials updated: ${updatedCount}`);
    console.log(`üìä Materials created: ${createdCount}`);

  } catch (error) {
    console.error('‚ùå Error during update:', error);
    throw error;
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–≤–æ–¥–æ–≤
async function syncTranslations() {
  console.log('üåê Syncing translations...');

  try {
    const materials = await prisma.material.findMany({
      include: {
        translations: true
      }
    });

    let syncedCount = 0;

    for (const material of materials) {
      const existingLanguages = material.translations.map(t => t.language);
      const missingLanguages = SUPPORTED_LANGUAGES.filter(lang => !existingLanguages.includes(lang));

      if (missingLanguages.length > 0) {
        console.log(`üìù Material ${material.id} missing translations: ${missingLanguages.join(', ')}`);
        
        // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
        // –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏—è placeholder –ø–µ—Ä–µ–≤–æ–¥–æ–≤
        syncedCount++;
      }
    }

    console.log(`‚úÖ Translation sync completed. ${syncedCount} materials need attention.`);

  } catch (error) {
    console.error('‚ùå Error during translation sync:', error);
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ –≤ JSON
async function exportMaterials(profession = null, language = null) {
  console.log('üì§ Exporting materials...');

  try {
    const where = {};
    if (profession) where.profession = profession;
    if (language) {
      where.translations = {
        some: {
          language: language
        }
      };
    }

    const materials = await prisma.material.findMany({
      where,
      include: {
        translations: true
      }
    });

    const exportDir = path.join(__dirname, '..', 'exports');
    if (!fs.existsSync(exportDir)) {
      fs.mkdirSync(exportDir, { recursive: true });
    }

    const exportFile = path.join(exportDir, `materials-export-${Date.now()}.json`);
    fs.writeFileSync(exportFile, JSON.stringify(materials, null, 2));

    console.log(`‚úÖ Export completed: ${exportFile}`);
    console.log(`üìä Exported ${materials.length} materials`);

  } catch (error) {
    console.error('‚ùå Error during export:', error);
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
const args = process.argv.slice(2);
const command = args[0];
const profession = args[1];
const language = args[2];

switch (command) {
  case 'update':
    updateMaterials(profession, language);
    break;
  case 'validate':
    validateJsonFiles();
    break;
  case 'sync':
    syncTranslations();
    break;
  case 'export':
    exportMaterials(profession, language);
    break;
  case 'backup':
    createBackup();
    break;
  default:
    console.log('Usage:');
    console.log('  node update-materials.js update [profession] [language] - Update materials');
    console.log('  node update-materials.js validate                      - Validate JSON files');
    console.log('  node update-materials.js sync                         - Sync translations');
    console.log('  node update-materials.js export [profession] [language] - Export materials');
    console.log('  node update-materials.js backup                       - Create backup');
    console.log('');
    console.log('Examples:');
    console.log('  node update-materials.js update                        - Update all materials');
    console.log('  node update-materials.js update frontend-developer     - Update specific profession');
    console.log('  node update-materials.js update frontend-developer en  - Update specific profession and language');
    break;
}

// –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
process.on('SIGINT', async () => {
  await prisma.$disconnect();
  process.exit(0);
});
