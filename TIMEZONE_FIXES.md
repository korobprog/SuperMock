# Исправления проблем с часовыми поясами

## Проблемы, которые были исправлены

### 1. Неправильная конвертация локального времени в UTC

**Проблема:** В функции `convertLocalToUTC` использовалась неправильная логика конвертации:
```javascript
// ❌ Неправильно
const utcDate = new Date(localDate.getTime() + timezoneOffset * 60000);
```

**Решение:** Использование библиотеки `luxon` для правильной работы с часовыми поясами:
```javascript
// ✅ Правильно
const localDate = DateTime.now().setZone(timezone);
const slotDate = localDate.set({ hour: hours, minute: minutes, second: 0, millisecond: 0 });
const utcDate = slotDate.toUTC();
```

### 2. Неправильное создание UTC слотов

**Проблема:** В функции `handleNext` использовалось локальное время вместо UTC:
```javascript
// ❌ Неправильно
const utcDate = new Date();
utcDate.setUTCFullYear(today.getUTCFullYear());
utcDate.setUTCMonth(today.getUTCMonth());
utcDate.setUTCDate(today.getUTCDate());
utcDate.setUTCHours(Number(hh), Number(mm), 0, 0);
```

**Решение:** Использование функции `createUTCSlotFromLocal`:
```javascript
// ✅ Правильно
const slotsUtc = selectedSlots.map((s) => {
  return createUTCSlotFromLocal(s);
});
```

### 3. Неправильное отображение времени слотов

**Проблема:** Слоты отображались в UTC времени, а не в локальном времени пользователя.

**Решение:** Конвертация UTC времени обратно в локальное для отображения:
```javascript
// ✅ Правильно
for (const s of candidateRes.slots) {
  const localTime = convertUTCToLocal(s.time);
  candidateMap[localTime] = s.count;
}
```

## Ключевые изменения

### Frontend (`frontend/src/pages/TimeSelection.tsx`)

1. **Добавлен импорт luxon:**
   ```javascript
   import { DateTime } from 'luxon';
   ```

2. **Исправлены функции конвертации времени:**
   - `convertLocalToUTC()` - правильная конвертация локального времени в UTC
   - `convertUTCToLocal()` - конвертация UTC времени в локальное для отображения
   - `createUTCSlotFromLocal()` - создание правильного UTC слота

3. **Исправлена функция загрузки слотов:**
   - Использование локальной даты для определения дня
   - Конвертация UTC времен обратно в локальные для отображения

4. **Добавлена отладочная информация:**
   - Отображение UTC времени выбранного слота
   - Функция отладки конвертации времени (в режиме разработки)

### Backend (уже работал правильно)

Бэкенд уже использовал библиотеку `luxon` и правильно обрабатывал часовые пояса:
- Правильное вычисление временных окон дня
- Корректная группировка слотов по UTC времени
- Правильная логика матчинга

## Как это работает

### 1. Создание слотов
1. Пользователь выбирает время в своем локальном часовом поясе (например, 14:00 в Москве)
2. Фронтенд конвертирует это время в UTC (14:00 Москва → 11:00 UTC)
3. UTC время сохраняется в базе данных

### 2. Отображение слотов
1. Бэкенд возвращает слоты в UTC времени
2. Фронтенд конвертирует UTC время обратно в локальное время пользователя для отображения
3. Пользователь видит время в своем часовом поясе

### 3. Матчинг
1. Все слоты хранятся в UTC времени
2. Матчинг происходит по UTC времени
3. Пользователи из разных часовых поясов могут быть сопоставлены, если их локальные времена соответствуют одному UTC времени

## Тестирование

### Тестовые скрипты
1. `test-timezone-slots.cjs` - тестирование логики конвертации времени
2. `test-frontend-timezone.cjs` - тестирование логики фронтенда
3. `create-test-slots.cjs` - создание тестовых слотов для проверки матчинга

### Пример тестирования
```bash
# Запуск тестов
node test-timezone-slots.cjs
node test-frontend-timezone.cjs

# Создание тестовых слотов (требует запущенный сервер)
node create-test-slots.cjs
```

## Результат

После исправлений:
- ✅ Пользователи видят время в своем локальном часовом поясе
- ✅ Слоты создаются в правильном UTC времени
- ✅ Матчинг работает между пользователями из разных часовых поясов
- ✅ Отображение количества пользователей корректно
- ✅ Рекомендации слотов работают правильно

## Пример работы

**Сценарий:** Пользователь из Москвы (UTC+3) и пользователь из Нью-Йорка (UTC-4) выбирают 14:00 по своему местному времени.

1. **Москва 14:00** → **UTC 11:00**
2. **Нью-Йорк 14:00** → **UTC 18:00** (следующий день)

Эти пользователи НЕ будут сопоставлены, так как их локальные 14:00 соответствуют разным UTC временам.

**Сценарий:** Пользователь из Москвы выбирает 14:00, а пользователь из Нью-Йорка выбирает 7:00.

1. **Москва 14:00** → **UTC 11:00**
2. **Нью-Йорк 7:00** → **UTC 11:00**

Эти пользователи БУДУТ сопоставлены, так как их локальные времена соответствуют одному UTC времени.
