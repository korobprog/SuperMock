generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String         @id @map("id")
  tgId                  String?        @map("tg_id")
  username              String?
  firstName             String?        @map("first_name")
  lastName              String?        @map("last_name")
  language              String?
  createdAt             DateTime       @default(now()) @map("created_at")
  updatedAt             DateTime       @updatedAt @map("updated_at")
  photoUrl              String?        @map("photo_url")
  lastLoginAt           DateTime?      @map("last_login_at")
  feedbackGiven         Feedback[]     @relation("FeedbackFrom")
  feedbackReceived      Feedback[]     @relation("FeedbackTo")
  matchesAsCandidate    Match[]        @relation("MatchCandidate")
  matchesAsInterviewer  Match[]        @relation("MatchInterviewer")
  notifications         Notification[]
  preferences           Preference[]
  sessionsAsCandidate   Session[]      @relation("CandidateSessions")
  sessionsAsInterviewer Session[]      @relation("InterviewerSessions")
  queues                UserQueue[]
  userSettings          UserSettings?
  userTools             UserTool[]

  @@map("users")
}

model UserTool {
  id         Int      @id @default(autoincrement())
  userId     String   @map("user_id")
  profession String
  toolName   String   @map("tool_name")
  category   String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, profession])
  @@index([toolName, profession])
  @@map("user_tools")
}

model Preference {
  id         Int      @id @default(autoincrement())
  userId     String   @map("user_id")
  role       String
  profession String
  language   String
  slotsUtc   String   @map("slots_utc")
  createdAt  DateTime @default(now()) @map("created_at")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("preferences")
}

model Session {
  id                String           @id
  interviewerUserId String?          @map("interviewer_user_id")
  candidateUserId   String?          @map("candidate_user_id")
  profession        String?
  language          String?
  slotUtc           String?          @map("slot_utc")
  createdAt         DateTime         @default(now()) @map("created_at")
  status            String?
  jitsiRoom         String?          @map("jitsi_room")
  completedAt       DateTime?        @map("completed_at")
  feedback          Feedback[]
  questionRatings   QuestionRating[]
  candidate         User?            @relation("CandidateSessions", fields: [candidateUserId], references: [id])
  interviewer       User?            @relation("InterviewerSessions", fields: [interviewerUserId], references: [id])

  @@map("sessions")
}

/// Очереди пользователей на слоты
model UserQueue {
  id         Int      @id @default(autoincrement())
  userId     String   @map("user_id")
  role       String
  profession String?
  language   String?
  slotUtc    String   @map("slot_utc")
  status     String   @default("waiting")
  createdAt  DateTime @default(now()) @map("created_at")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([slotUtc, role, status])
  @@index([userId, status])
  @@map("user_queues")
}

/// Таблица зафиксированных матчей кандидат-интервьюер (для аудита)
model Match {
  id            Int      @id @default(autoincrement())
  candidateId   String   @map("candidate_id")
  interviewerId String   @map("interviewer_id")
  slotUtc       String   @map("slot_utc")
  status        String   @default("scheduled")
  sessionId     String?  @map("session_id")
  meetingLink   String?  @map("meeting_link")
  createdAt     DateTime @default(now()) @map("created_at")
  candidate     User     @relation("MatchCandidate", fields: [candidateId], references: [id])
  interviewer   User     @relation("MatchInterviewer", fields: [interviewerId], references: [id])

  @@index([slotUtc, status])
  @@map("matches")
}

/// Уведомления для пользователей (включая дубликаты в Telegram)
model Notification {
  id          Int       @id @default(autoincrement())
  userId      String    @map("user_id")
  type        String
  title       String
  message     String
  status      String    @default("active")
  priority    Int       @default(0)
  actionData  String?   @map("action_data")
  createdAt   DateTime  @default(now()) @map("created_at")
  readAt      DateTime? @map("read_at")
  expiresAt   DateTime? @map("expires_at")
  messageData String?   @map("message_data")
  messageKey  String?   @map("message_key")
  titleKey    String?   @map("title_key")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status, createdAt])
  @@map("notifications")
}

model Feedback {
  id              Int      @id @default(autoincrement())
  sessionId       String   @map("session_id")
  fromUserId      String   @map("from_user_id")
  toUserId        String   @map("to_user_id")
  rating          Int
  comments        String?
  createdAt       DateTime @default(now()) @map("created_at")
  ratings         String?
  recommendations String?
  fromUser        User     @relation("FeedbackFrom", fields: [fromUserId], references: [id])
  session         Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  toUser          User     @relation("FeedbackTo", fields: [toUserId], references: [id])

  @@index([sessionId])
  @@index([fromUserId])
  @@index([toUserId])
  @@map("feedback")
}

model QuestionRating {
  id            Int      @id @default(autoincrement())
  sessionId     String   @map("session_id")
  questionIndex Int      @map("question_index")
  questionText  String   @map("question_text")
  isAsked       Boolean  @default(false) @map("is_asked")
  rating        Int?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  session       Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, questionIndex])
  @@map("question_ratings")
}

model UserSettings {
  id               Int      @id @default(autoincrement())
  userId           String   @unique @map("user_id")
  openrouterApiKey String?  @map("openrouter_api_key")
  preferredModel   String   @default("meta-llama/llama-3.1-8b-instruct") @map("preferred_model")
  questionsLevel   String   @default("middle") @map("questions_level")
  useAiGeneration  Boolean  @default(false) @map("use_ai_generation")
  questionsCount   Int      @default(10) @map("questions_count")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")
  stackblitzApiKey String?  @map("stackblitz_api_key")
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model Material {
  id           Int                   @id @default(autoincrement())
  profession   String
  category     String
  difficulty   String
  readTime     Int                   @map("read_time")
  rating       Float                 @default(0)
  reads        Int                   @default(0)
  tags         String[]
  isNew        Boolean               @default(false) @map("is_new")
  isPopular    Boolean               @default(false) @map("is_popular")
  createdAt    DateTime              @default(now()) @map("created_at")
  updatedAt    DateTime              @updatedAt @map("updated_at")
  translations MaterialTranslation[]

  @@index([profession, category])
  @@index([profession, difficulty])
  @@index([isPopular, createdAt])
  @@map("materials")
}

model MaterialTranslation {
  id          Int      @id @default(autoincrement())
  materialId  Int      @map("material_id")
  language    String
  title       String
  description String
  content     String
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  material    Material @relation(fields: [materialId], references: [id], onDelete: Cascade)

  @@unique([materialId, language])
  @@index([language])
  @@map("material_translations")
}
